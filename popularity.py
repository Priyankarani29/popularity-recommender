# -*- coding: utf-8 -*-
"""popularity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wG2e5HeGdd-TSz5E2EReH_pA0FBfgFUK
"""


# --------------------------------------
# ðŸŽµ Spotify AI Recommender - Full App
# --------------------------------------

# ðŸ“¦ Imports
import streamlit as st
import pandas as pd
import numpy as np
import json
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, f1_score, roc_auc_score, roc_curve
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from xgboost import XGBClassifier
from sklearn.metrics.pairwise import cosine_similarity
import matplotlib.pyplot as plt
import seaborn as sns

# ðŸ› ï¸ Streamlit App Config
st.set_page_config(page_title="ðŸŽµ Spotify AI Recommender", layout="wide")

# --------------------------------------
# ðŸ“… Load Data
# --------------------------------------
@st.cache_data(show_spinner=True)
def load_data():
    df = pd.read_csv("spotify_tracks.csv", low_memory=False)
    df = df.drop_duplicates(subset=['track_name', 'track_genre'], keep='first')
    audio_cols = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
                  'instrumentalness', 'liveness', 'tempo', 'duration_ms', 'valence']
    df[audio_cols] = df[audio_cols].fillna(df[audio_cols].mean()).astype(np.float32)
    return df, audio_cols

spotify_df, model_features = load_data()
X_valence = spotify_df[model_features[:-1]]
y_valence = (spotify_df['valence'] > 0.5).astype(int)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_valence)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_valence, test_size=0.2, random_state=42)

# --------------------------------------
# ðŸ” Sidebar Navigation
# --------------------------------------
st.sidebar.title("Navigation")
page = st.sidebar.radio("Go to", [
    "EDA Dashboard", 
    "Model Evaluation", 
    "ML-Based Recommendation", 
    "Cosine Similarity Recommendation",
    "Hybrid Recommendation"
])

# --------------------------------------
# ðŸ“Š EDA Dashboard
# --------------------------------------
if page == "EDA Dashboard":
    st.title("ðŸ“Š Spotify Dataset - EDA Dashboard")
    st.write(f"**Total Records:** {spotify_df.shape[0]:,}")
    st.dataframe(spotify_df[model_features].describe(), use_container_width=True)

    st.subheader("ðŸŽ§ Genre Distribution (Top 20)")
    st.bar_chart(spotify_df['track_genre'].value_counts().head(20))

    st.subheader("ðŸ“ˆ Correlation Heatmap")
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.heatmap(spotify_df[model_features].corr(), annot=False, cmap='coolwarm', ax=ax)
    st.pyplot(fig)

    st.subheader("ðŸ” Feature Histogram")
    feature = st.selectbox("Choose Feature", model_features)
    fig2, ax2 = plt.subplots()
    sns.histplot(spotify_df[feature], kde=True, ax=ax2, bins=30)
    st.pyplot(fig2)

# --------------------------------------
# ðŸ§  Model Evaluation 
# --------------------------------------
elif page == "Model Evaluation":
    st.title("ðŸ§  Model Evaluation")
    models = {
        "Logistic Regression": LogisticRegression(max_iter=1000),
        "Random Forest": RandomForestClassifier(n_estimators=200),
        "XGBoost": XGBClassifier(use_label_encoder=False, eval_metric='logloss')
    }

    results = []
    fig, ax = plt.subplots(figsize=(8, 6))
    best_auc = 0
    best_model = None
    selected_model_name = ""

    for name, model in models.items():
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        y_prob = model.predict_proba(X_test)[:, 1]

        acc = accuracy_score(y_test, y_pred)
        f1 = f1_score(y_test, y_pred)
        auc = roc_auc_score(y_test, y_prob)
        results.append({"Model": name, "Accuracy": acc, "F1 Score": f1, "ROC AUC": auc})

        st.markdown(f"### ðŸ“Œ {name} Performance")
        st.text(classification_report(y_test, y_pred))
        st.markdown(f"**Accuracy:** `{acc:.4f}` | **F1 Score:** `{f1:.4f}` | **ROC AUC:** `{auc:.4f}`")

        if auc > best_auc:
            best_auc = auc
            best_model = model
            selected_model_name = name

        fpr, tpr, _ = roc_curve(y_test, y_prob)
        ax.plot(fpr, tpr, label=f"{name} (AUC = {auc:.2f})")

    ax.plot([0, 1], [0, 1], linestyle='--', color='gray')
    ax.set_xlabel("False Positive Rate")
    ax.set_ylabel("True Positive Rate")
    ax.set_title("ROC Curve Comparison")
    ax.legend()
    st.pyplot(fig)

    results_df = pd.DataFrame(results).sort_values("ROC AUC", ascending=False)
    st.subheader("ðŸ“Š Model Performance Summary")
    st.dataframe(results_df.style.format({"Accuracy": "{:.4f}", "F1 Score": "{:.4f}", "ROC AUC": "{:.4f}"}))

    st.success(f"âœ… Best model selected for prediction: `{selected_model_name}`")
    st.session_state.best_model = best_model
    st.session_state.selected_model_name = selected_model_name


        except Exception as e:
            st.error(f"Error processing uploaded file: {e}")
    else:
        st.info("Please upload a JSON file containing your playlist with audio features.")

# --------------------------------------
# ðŸŽµ ML-Based Recommendation (Upload + Filters)
# --------------------------------------
elif page == "ML-Based Recommendation":
    st.title("ðŸŽµ ML-Based Mood Song Recommender with Filters")
    st.markdown("Upload your playlist, get mood predictions, and apply filters like genre and mood.")

    if "best_model" not in st.session_state:
        st.warning("Please evaluate models first from the 'Model Evaluation' tab.")
    else:
        uploaded_file = st.file_uploader("ðŸ“¤ Upload your playlist JSON file (with audio features)", type="json")

        if uploaded_file:
            try:
                user_data = json.load(uploaded_file)
                user_df = pd.DataFrame(user_data)
                user_df = user_df.dropna(subset=model_features[:-1])

                valence_model = st.session_state.best_model
                selected_model_name = st.session_state.selected_model_name
                valence_model.fit(X_scaled, y_valence)

                user_scaled = scaler.transform(user_df[model_features[:-1]])
                predictions = valence_model.predict(user_scaled)

                user_df['predicted_valence'] = predictions
                user_df['mood'] = user_df['predicted_valence'].apply(lambda x: 'Happy' if x == 1 else 'Calm')

                st.success(f"âœ… Model used: `{selected_model_name}`")
                st.subheader("ðŸŽ§ Mood Predictions for Uploaded Songs")

                col1, col2 = st.columns(2)
                with col1:
                    genre_options = sorted(user_df['track_genre'].dropna().unique())
                    selected_genres = st.multiselect("ðŸŽ¼ Filter by Genre(s)", genre_options)
                with col2:
                    selected_mood = st.radio("ðŸŽ­ Filter by Mood", ["All", "Happy", "Calm"])

                filtered_df = user_df.copy()
                if selected_genres:
                    filtered_df = filtered_df[filtered_df['track_genre'].isin(selected_genres)]
                if selected_mood != "All":
                    filtered_df = filtered_df[filtered_df['mood'] == selected_mood]

                if filtered_df.empty:
                    st.warning("No songs match the selected filters.")
                else:
                    st.dataframe(filtered_df[['track_name', 'track_genre', 'valence', 'mood']], use_container_width=True)

            except Exception as e:
                st.error(f"Error processing uploaded file: {e}")
        else:
            st.info("Please upload a JSON file with songs and their audio features.")

# --------------------------------------
# ðŸŽ§ Cosine Similarity Recommendation (Upload + Filters + Global Top N)
# --------------------------------------
elif page == "Cosine Similarity Recommendation":
    st.title("ðŸŽ§ Content-Based Recommendation (Cosine Similarity)")
    st.markdown("Upload your playlist to find similar tracks based on audio features, with genre and mood filters.")

    uploaded_file = st.file_uploader("ðŸ“¤ Upload your playlist JSON file (with audio features)", type="json")

    if uploaded_file:
        try:
            user_data = json.load(uploaded_file)
            user_df = pd.DataFrame(user_data)
            user_df = user_df.dropna(subset=model_features[:-1])

            user_vectors = user_df[model_features[:-1]].values
            spotify_vectors = spotify_df[model_features[:-1]].values
            sim_matrix = cosine_similarity(user_vectors, spotify_vectors)

            all_scores = sim_matrix.flatten()
            scores_df = spotify_df.copy()
            scores_df = pd.concat([scores_df] * len(user_df), ignore_index=True)
            scores_df['similarity_score'] = all_scores
            scores_df['mood'] = scores_df['valence'].apply(lambda x: 'Happy' if x > 0.5 else 'Calm')

            col1, col2 = st.columns(2)
            with col1:
                genre_options = sorted(scores_df['track_genre'].dropna().unique())
                selected_genres = st.multiselect("ðŸŽ¼ Filter by Genre(s)", genre_options)
            with col2:
                selected_mood = st.radio("ðŸŽ­ Filter by Mood", ["All", "Happy", "Calm"])

            filtered_df = scores_df.copy()
            if selected_genres:
                filtered_df = filtered_df[filtered_df['track_genre'].isin(selected_genres)]
            if selected_mood != "All":
                filtered_df = filtered_df[filtered_df['mood'] == selected_mood]

            top_n = st.slider("Select number of top songs to display", 3, 50, 10)
            final_recommendations = filtered_df.sort_values("similarity_score", ascending=False).head(top_n)

            if final_recommendations.empty:
                st.warning("No songs match the selected filters.")
            else:
                st.subheader(f"ðŸŽ¯ Top {top_n} Filtered Similar Songs")
                st.dataframe(final_recommendations[['track_name', 'track_genre', 'valence', 'mood', 'similarity_score']], use_container_width=True)

        except Exception as e:
            st.error(f"Error processing uploaded file: {e}")
    else:
        st.info("Please upload a JSON file containing your playlist with audio features.")

# --------------------------------------
# ðŸŽ§ Hybrid Recommendation (Mood + Cosine Similarity)
# --------------------------------------
elif page == "Hybrid Recommendation":
    st.title("ðŸŽ§ Hybrid Recommender: Mood + Similarity")
    st.markdown("Get recommendations that are similar in sound and match the mood predicted by the ML model.")

    if "best_model" not in st.session_state:
        st.warning("Please evaluate models first from the 'Model Evaluation' tab.")
    else:
        uploaded_file = st.file_uploader("ðŸ“¤ Upload your playlist JSON file (with audio features)", type="json")

        if uploaded_file:
            try:
                user_data = json.load(uploaded_file)
                user_df = pd.DataFrame(user_data)
                user_df = user_df.dropna(subset=model_features[:-1])

                valence_model = st.session_state.best_model
                selected_model_name = st.session_state.selected_model_name
                valence_model.fit(X_scaled, y_valence)

                user_scaled = scaler.transform(user_df[model_features[:-1]])
                predictions = valence_model.predict(user_scaled)
                user_df['predicted_valence'] = predictions
                user_df['mood'] = user_df['predicted_valence'].apply(lambda x: 'Happy' if x == 1 else 'Calm')

                st.success(f"âœ… Mood predicted using: `{selected_model_name}`")
                st.subheader("ðŸ“¥ Uploaded Playlist with Predicted Mood")
                st.dataframe(user_df[['track_name', 'track_genre', 'valence', 'mood']], use_container_width=True)

                spotify_df['mood'] = spotify_df['valence'].apply(lambda x: 'Happy' if x > 0.5 else 'Calm')
                spotify_vectors = spotify_df[model_features[:-1]].values
                user_vectors = user_df[model_features[:-1]].values
                sim_matrix = cosine_similarity(user_vectors, spotify_vectors)

                top_n = st.slider("Select number of top similar + mood-matched songs", 3, 50, 10)
                recommendations = []

                for i, row in user_df.iterrows():
                    mood = row['mood']
                    sim_scores = sim_matrix[i]
                    mood_mask = spotify_df['mood'] == mood
                    mood_df = spotify_df[mood_mask].copy()
                    mood_df['similarity_score'] = sim_scores[mood_mask.to_numpy()]
                    mood_df['source_track'] = row['track_name']
                    mood_df['source_mood'] = mood
                    top_matches = mood_df.sort_values("similarity_score", ascending=False).head(top_n)
                    recommendations.append(top_matches)

                final_recommendations = pd.concat(recommendations, ignore_index=True)

                st.subheader("ðŸŽ¯ Hybrid Recommended Songs")
                st.dataframe(final_recommendations[['source_track', 'track_name', 'track_genre', 'mood', 'similarity_score']], use_container_width=True)

            except Exception as e:
                st.error(f"Error processing uploaded file: {e}")
        else:
            st.info("Please upload a playlist with audio features.")
